[{"title":"buuCTF-Web","date":"2023-07-06T14:59:46.000Z","url":"/2023/07/06/buuCTF-Web/","tags":[["Web","/tags/Web/"],["buuCTF","/tags/buuCTF/"]],"categories":[["CTF","/categories/CTF/"]],"content":"[极客大挑战 2019]Havefun 看页面源码，发个cat&#x3D;dog的query即可 [HCTF 2018]WarmUpf12页面提示我们访问source.php 网页源代码 包含hint后得知我们最后需要包含ffffllllaaaagggg文件 吧没什么用的代码删一下 我们需要想办法使她返回true 可知我们的参数需要满足以下格式 source.php?[something] 或 hint.php?[something] 最后的query参数为?file=source.php?../../../../../ffffllllaaaagggg 实际include的文件为 source.php?../../../../../ffffllllaaaagggg 疑问这里有一个不理解，就是?会怎么处理，实验发现貌似?被忽略了 [ACTF2020 新生赛]Include进来就一个tips，点一下跳转到/?file=flag.php 一开始猜是任意文件包含，然后看了一下好像没啥可构造的，源码干净的一批 然后就想如何获取源码，有了源码一切就好说了 答案是php伪协议 PHP伪协议总结 php://filter/read=convert.base64-encode/resource=flag.php 读取php文件源码（不然就被执行了）&#96; [ACTF2020 新生赛]Exec看名字Exec（执行）然后网页上一个大大的ping那猜测是直接用系统的ping命令使用命令localhost;ls测试，成功输出了文件列表localhost;ls \\找到flaglocalhost;cat \\flag获取flag [GXYCTF2019]Ping Ping Ping这道题和 ‘[ACTF2020 新生赛]Exec’很相似，但是加了N多屏蔽 ls完了发现需要cat一下flag.php 这里的php过滤很狠，过滤了空格，换行符，等等 查阅资料发现可以用以下方式绕过 $IFS (这是Linux命令和参数的分隔符)${IFS}$IFS$1 &#x2F;&#x2F;1 改 成 1改成1改成加其他数字貌似都行，这里主要是让$停止识别IFS之后的字母&lt; 这俩不明白&lt;&gt;{cat,flag.php} &#x2F;&#x2F;用逗号实现了空格功能%20 url编码%09 这是啥？？？？？？？？？？ 注，cat有时候被屏蔽，可以用tac，或者 linux命令中可以加 \\，所以甚至可以 ca\\t &#x2F;fl\\ag 通过这个尝试查看源码 过滤了相当多的东西，而且flag有正则匹配 此处对flag的绕过采用了Linux Shell变量的方法： /ip=1;a=g;cat$IFS$1fla$a.php 查看网页源码得flag"},{"title":"操作系统实验六","date":"2023-06-25T09:21:46.000Z","url":"/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%85%AD/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["Liunx","/tags/Liunx/"]],"categories":[["操作系统上机实验","/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"]],"content":"同步机制——信号量集与哲学家就餐问题 实验目的：理解Linux系统中基于信号量集的同步机制，并使用该同步机制解决并发进程的同步问题。实验内容： 定义5把叉子的信号量集。 编写5个哲学家的就餐活动，解决哲学家就餐时对叉子资源的申请和释放。 用fork()系统调用创建5个哲学家进程并使其并发执行，通过观察运行结果判断同步算法的正确性。 实验代码 实验结果 解决方案中是否出现饥饿？为什么？存在饥饿 当多个哲学家同时饥饿并尝试获取筷子时，可能发生死锁。死锁是指一组进程互相等待对方所持有的资源，导致所有进程都无法继续执行。 在这个代码中，如果每个哲学家都饥饿并尝试获取左右两边的筷子，但同时只有一个筷子可用，那么所有哲学家都会陷入饥饿状态，并且无法解除。这种情况下，每个哲学家都无法获得所需的两个筷子，无法进餐，从而导致饥饿问题的发生。"},{"title":"操作系统实验五","date":"2023-06-25T08:53:38.000Z","url":"/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%94/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["Liunx","/tags/Liunx/"]],"categories":[["操作系统上机实验","/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"]],"content":"文件系统——散列结构文件的构造 实验目的： 掌握Linux中与文件有关的系统调用命令的功能和使用，理解文件的物理组织结构。 实验内容： 设计一组关于物理结构为散列结构的文件的操作函数，包括创建、打开、关闭、读、写。 构造一个散列结构的文件，实现记录保存、查找、删除。 编写记录更新函数。 设计原理： 参考教材8.3.2 实验代码 hashfile.h hashifile.c jtRecord.h jtRecord.c 运行结果 HashFile.h定义了哈希文件的基本结构和操作，包括创建、打开、关闭、读、写、删除、查找和保存记录等函数。 HashFile.c实现了哈希文件的所有操作。 jtRecord.h定义了一个结构体jtRecord，用于保存数据记录，包括键（key）和其他信息（other）。 jtRecord.c包含了对哈希文件的操作代码，包括打开文件、保存记录、显示文件、查找记录、删除记录、读取和写入记录等。 以下是对每个功能的描述： 创建哈希文件：创建一个文件，文件头部保存哈希文件的元信息，如总记录数、当前记录数等。 打开哈希文件：打开一个文件，首先读取文件头部的元信息，确认其为正确的哈希文件。 关闭哈希文件：关闭一个打开的文件。 读取哈希文件：根据关键字找到哈希地址，然后读取该地址的记录。 写入哈希文件：将一条记录保存到文件中，首先计算关键字的哈希地址，然后将记录保存到该地址。 删除哈希文件记录：根据关键字找到哈希地址，然后删除该地址的记录。 查找哈希文件记录：根据关键字计算哈希地址，然后在文件中找到对应的记录。 请给出实验过程中遇到的问题，并解释原因和解决方案下面是对所提到的修改的转写： 在HashFile.h中添加了以下内容： 在HashFile.h中添加了以下内容： 在HashFile.h中，将hashfile_creat函数的参数名recnum改为total_rec_num，并将hash函数的参数名recnum改为total_rec_num，以解决参数命名不一致导致的错误。 在HashFile.c中添加了以下内容： 将HashFile.c中的tag.free=1;修改为tag.free=-1;，以改变tag结构体中的free字段的赋值。 如果模拟一个inode区的前提下，请指出参考代码中creat函数需要如何修改？如果要模拟一个inode区，creat函数需要进行如下修改： 在创建文件之前，需要分配一个新的inode来存储文件的元数据。可以使用一个自定义的数据结构来表示inode，其中包含文件的大小、类型、权限和数据块地址等信息。 需要修改创建文件时的逻辑，将文件的元数据信息存储到新分配的inode中。可以通过在inode区中查找一个可用的inode块，或者使用链表等数据结构来管理可用的inode块。 修改创建文件时的逻辑，将文件的数据块地址存储到inode中，以便后续读取和写入文件数据时可以使用。 在创建文件时，需要更新inode区的相关信息，如标记已使用的inode块、更新inode区的空闲inode块列表等。 请设计系统打开文件表和用户打开文件表，并给出相应函数的修改方案首先，定义打开文件表的数据结构，包括文件描述符（fd）、文件名（filename）、文件标志（flags）、打开模式（mode）等信息。可以使用一个数组来表示打开文件表，每个条目表示一个打开的文件。 然后，根据上述需求，在hashfile_open函数和hashfile_close函数中进行相应的修改。 在hashfile_open函数中的修改方案： 在hashfile_close函数中的修改方案： "},{"title":"操作系统实验四","date":"2023-06-25T08:26:07.000Z","url":"/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["Liunx","/tags/Liunx/"]],"categories":[["操作系统上机实验","/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"]],"content":"存储管理——可变分区存储管理的分配和回收 实验内容： 了解可变分区存储管理中对内存空间的划分策略以及存储区的组织结构。 分析UNIX最先适应（FF）存储分配算法，仔细阅读UNIX源代码中map数据结构、malloc()存储分配函数、mfree()存储释放函数。 参照UNIX代码编写最佳适应分配算法和最坏适应分配算法。 设计原理： 参考教材13.4.2 实验代码 文本代码 实验结果 结果 实验过程中遇到的问题，原因和解决方法 无论程序运行过程中输入b还是w，执行的都是WF。int c 改为char c后解决 scanf后需要getchar读取换行 main函数的do-while循环中把第一个printf删去 scanf里面改为%c 实验代码中空闲区域表中空闲区按何种顺序组织，如果按尺寸由小到大和由大到小组织，算法应该如何修改？"},{"title":"操作系统实验三","date":"2023-06-07T14:34:03.000Z","url":"/2023/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["Liunx","/tags/Liunx/"]],"categories":[["操作系统上机实验","/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"]],"content":"处理器调度——实时调度算法EDF 实验内容： 在Linux环境下采用用户级别线程模拟实现EDF实时调度算法。 给定一组周期性实时任务并判断是否可调度。 如果可调度，请按算法模拟调度次序，并在终端给出Gantt图。 设计原理： select_proc()实现调度算法，proc()执行任务，idle()没有可执行任务时执行，main()初始化。 为每个线程设计了一个等待锁，暂不运行的任务等待在相应的锁变量上。 主线程按调度算法唤醒子线程，子线程执行一个时间单位后把控制权交给主线程判断是否需要重新调度 实验过程如下 处理器调度——实时调度算法EDF 文本代码 编译并运行，结果如下 1.clone和pthread_create的区别？ 功能： clone：clone函数是Linux系统提供的系统调用，它可以创建一个新的进程或线程。它提供了更灵活的选项，可以指定新线程所继承的父线程的资源，如文件描述符表、内存空间等。因此，clone函数可以创建线程，也可以创建进程，还可以实现进程间的共享资源。 pthread_create：pthread_create函数是POSIX线程库（pthread）提供的函数，用于创建一个新的线程。它只能用于创建线程，不能创建进程。它创建的线程与父线程共享进程的资源，如文件描述符表和内存空间。 调用方式： clone：clone函数是一个系统调用，使用时需要通过提供一个函数指针作为参数，指定新线程要执行的函数。调用clone函数时，需要指定一系列的标志和选项来设置新线程的行为和继承关系。 pthread_create：pthread_create函数是一个库函数，使用时需要提供一个函数指针作为参数，指定新线程要执行的函数。调用pthread_create函数时，只需要提供线程的属性和参数等少量参数即可。 平台兼容性： clone：clone函数是Linux特有的系统调用，因此只能在Linux系统上使用。 pthread_create：pthread_create函数是POSIX标准定义的函数，几乎所有的主流操作系统都支持POSIX线程库，所以pthread_create函数可以在多个操作系统上使用。 clone函数提供了更多的灵活性，可以创建线程或进程，并且可以继承父线程的资源。而pthread_create函数只能创建线程，并且新线程与父线程共享进程的资源。选择使用哪个函数取决于具体的需求和平台的兼容性要求。 2.调度算法中ci_left和ti_left作用？在这段代码中，ci_left和ti_left分别表示实时任务的剩余执行时间和剩余周期时间。 ci_left：表示实时任务的剩余执行时间。在每个时间单位内，实时任务的ci_left会递减，表示任务执行了一个时间单位。当ci_left减至0时，表示该任务完成了当前周期的执行。 ti_left：表示实时任务的剩余周期时间。在每个时间单位内，实时任务的ti_left会递减。当ti_left减至0时，表示当前周期结束，任务需要开始下一个周期的执行。 这两个变量在调度算法中的作用是： 执行实时任务：当调度器选择一个实时任务进行执行时，会通过减少ci_left的值来模拟任务的执行。每次执行一个时间单位，ci_left减1，直到减至0表示任务完成当前周期的执行。 控制周期性执行：通过递减ti_left的值，判断是否需要开始下一个周期的执行。当ti_left减至0时，表示当前周期结束，调度器会将ti_left重置为初始周期时间，以便任务开始下一个周期的执行。 这样，通过ci_left和ti_left的管理，调度器可以控制实时任务的执行时间和周期，实现实时任务的周期性执行和调度。 3.EDF算法任务执行序列如下，请分析你的实验结果是否与次一致，为什么？如何修改？（给出修改部分的代码） "},{"title":"操作系统实验二","date":"2023-05-22T00:53:39.000Z","url":"/2023/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C/","tags":[["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"],["Liunx","/tags/Liunx/"]],"categories":[["操作系统上机实验","/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"]],"content":"基于clone的系统调用 实验内容： 掌握clone()系统调用的形式和功能,了解线程间通过共享内存的方式实现通信。 sem_wait和sem_post相当于P、V操作，掌握它们的使用方法，以及信号量s的说明和初始化。 掌握pthread_mutex_lock和pthread_mutex_unlock的使用方法，理解如何实现临界区的互斥。 设计原理：用clone()创建4个轻进程，用参数指明共享内存等资源，通过共享内存模拟生产者-消费者问题实验过程如下 基于clone的系统调用 代码 保存为task2.c 编译&amp;运行 输出结果 输出结果 结果分析 clone()语句在创建进程时，可通过参数设定子进程与父进程是否共享存储空间 多个进程共享内存需要互斥机制，程序中定义了临界区变量mutex和信号量product，warehouse。临界区变量用于共享内存操作的互斥，信号量分别实现了生产者和消费者的等待。 消费者输出存储区中的数据，并且存储区中的数据随着生产者存入的数据而发生变化，说明clone()语句通过clone_flag的参数设定实现了共享内存。若在实验中除去CLONE_VM选项，将出现非预期的结果。 生产者 生产者线程通过循环来模拟生产10个产品的过程。 在每次生产之前，生产者线程会调用 sleep() 函数以不同的时间间隔等待（越来越慢）。 生产者线程首先调用 sem_wait(&amp;warehouse) 函数来获取 warehouse 信号量(获取后减一)，以确保有可用的缓冲区空间(初始为8)，否则等待消费者释放一个空间。 然后，它通过调用 pthread_mutex_lock(&amp;mutex) 函数获取互斥锁，以确保在修改共享缓冲区时不会发生冲突。 生产者根据线程的 ID (0 或 1) 将字符串 “aaa” 或 “bbb” 复制到缓冲区的下一个位置，并将 bp 增加。 生产者线程输出生产的产品信息。 最后，生产者线程释放互斥锁（调用 pthread_mutex_unlock(&amp;mutex)）并通过调用 sem_post(&amp;product) 函数增加 product 信号量的值，表示有一个新产品可用。 消费者 每个消费者线程通过调用 clone() 函数创建，并传递一个指向 consumer 函数的指针作为入口参数。 消费者线程通过循环来模拟消费10个产品的过程。 在每次消费之前，消费者线程会调用 sleep() 函数以不同的时间间隔等待。 消费者线程首先调用 sem_wait(&amp;product) 函数来获取 product 信号量(初始为0，获取到后减一，否则等待)，以确保有可用的产品可以消费。 然后，它通过调用 pthread_mutex_lock(&amp;mutex) 函数获取互斥锁，以确保在修改共享缓冲区时不会发生冲突。 消费者从缓冲区中取出最后一个产品，将其值复制为 “zzz”，然后将 bp 减少。 消费者线程输出消费的产品信息。 最后，消费者线程释放互斥锁（调用 pthread_mutex_unlock(&amp;mutex)）并通过调用 sem_post(&amp;warehouse) 函数增加 warehouse 信号量的值，表示有一个缓冲区空间可用。 问题分析 参考代码main中sleep的作用，若不修改sleep的参数会出现何种结果，为什么？ 实验过程中出现哪个问题，如何解决？ 参考代码main中sleep的作用，若不修改sleep的参数会出现何种结果，为什么？在给定的代码中，main函数中的sleep(1)用于在每次创建生产者和消费者线程后休眠1秒钟。这个休眠的作用是为了确保新创建的线程有足够的时间进行初始化和启动，以防止可能的竞争条件。在删除sleep函数后，只有生产者1和消费者1正常工作 实验过程中出现哪个问题，如何解决？无法编译gcc 编译多进程程序时需要加上编译选项 -pthread 主进程未等待在多次尝试执行时，输出以下结果后便终止 猜测原因是主进程过早退出，导致子进程没有执行完，在主函数结尾加一个sleep(56);后解决 在去除main函数的sleep函数后，主进程退出，但是后台进程仍在运行，可以正常输出 "},{"date":"2023-05-21T15:53:58.000Z","url":"/2023/05/21/%E5%8F%91%E6%83%85/","tags":[["发情","/tags/%E5%8F%91%E6%83%85/"]],"categories":[["杂","/categories/%E6%9D%82/"]],"content":"老公太可爱了"},{"title":"Java笔记1","date":"2023-03-14T15:01:28.000Z","url":"/2023/03/14/JavaNote1/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["Java","/tags/Java/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["Java","/categories/%E5%AD%A6%E4%B9%A0/Java/"]],"content":"环境配置 IDEA遇到需要你选关联文件的时候吧所有选项都勾上，之后方便一点，然后一直下一步就好 JDK 下载一个JDK17或者19就行，解压到 C:\\Program Files\\Java JDK系统变量设置(可选) Hello World1.字符集和标识符 Java语言采用Unicode字符集； Unicode字符是16bits存储格式，可以是包括中文在内的多国文字。 Java语言的标识符是以字母、下划线_或符号开头的后面含有字母、下划线、符号和数字的字符串，标识符的长度没有限制，但Java系统最多可以识别前255个字符。数字不能放在标识符的首位。 Java标识符中的字母是大小写相关的。 标识符命名惯例： 类和接口：大驼峰 SimpleApp 方法：calculateData 常量：PI、BASE_URL 变量：小驼峰 outputResult 2. 关键字 在Java中保留但已经不再使用的2个关键字：const，goto Java语言共规定了48个关键字，Java语言关键字都是小写的 3.数据类型 基本数据类型 整数类型：byte、short、int和long 浮点类型：float和double 字符类型：char 逻辑类型：boolean 整数类型的默认型为int型,整数类型都是有符号数。每一种整数类型的数都可以用8进制、10进制或者16进制格式来表示。 基本数据类型的封装类型 Integer类 Float类 Character类 Boolean类 看api文档去 "},{"title":"Java实践课1","date":"2023-03-14T09:31:24.000Z","url":"/2023/03/14/Java%E5%AE%9E%E8%B7%B5%E8%AF%BE1/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["Java","/tags/Java/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["Java","/categories/%E5%AD%A6%E4%B9%A0/Java/"],["作业","/categories/%E5%AD%A6%E4%B9%A0/Java/%E4%BD%9C%E4%B8%9A/"]],"content":"简单写了一下，算法及其低效 （选择结构练习）编写程序实现解一元二次方程的韦达定理求根公式 代码 （循环结构练习）利用迭代法求某正数a的平方根 计算公式为xn+1=(xn+a/xn)/2，试编写程序实现这个算法。其中：初始值为x0=a/2当xn+1与xn的差的绝对值小于一个正数 数值z时，即可以认为xn+1是所求的平方根。 代码 （循环结构练习）编写一个计算矩阵乘积的程序，完成对一个3×4矩阵和一个4× 5矩阵的乘法运算 代码 （循环结构练习）《孙子算经》卷下第二十六题 今有物不知其数， 三三数之剩二；五五数之剩三；七七数之剩二。问物几何?”这是一个著名的不定方程问题，意思是说有一个正整数，被3除的余数是2，被5除的余 数是3，被7除的余数是2，求这个数。试编写程序计算这个正整数,范围限定于105以内。 代码 main函数 为了方便读取输入，写了个工具类 代码 "},{"date":"2023-03-14T09:06:33.000Z","url":"/2023/03/14/%E8%80%83%E5%AE%8C%E8%AF%95%E4%BA%86/","categories":[["杂","/categories/%E6%9D%82/"]],"content":"出成绩了可去你妈的破离散数学 开个玩笑，我的问题 没辙，下学期好好学 下学期得学 信安(小离散)挂 微积分2缓 微积分3缓 学术英语(这个应该OK)缓 "},{"date":"2023-02-17T17:41:04.000Z","url":"/2023/02/18/%E5%8F%91%E6%83%85-2023-02-18/","tags":[["发情","/tags/%E5%8F%91%E6%83%85/"]],"categories":[["杂","/categories/%E6%9D%82/"]],"content":"就是发个情。嗯，没了"},{"title":"蓄水池算法（Reservoir Sampling)","date":"2023-02-04T09:01:50.000Z","url":"/2023/02/04/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["随机抽样","/tags/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["算法","/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"]],"content":"算法用于在一个未知长度的序列中随机取出某个或某些样本 其中每个样本被取出的概率均为 1/n 算法 假设数据序列的规模为 n，需要采样的数量的为 k。 首先构建一个可容纳 k 个元素的数组，将序列的前 k 个元素放入数组中。 然后从第 k+1 个元素开始，以 k/n 的概率来决定该元素最后是否被留在数组中（每进来一个新的元素，数组中的每个旧元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。 证明①对于数组中第 i 个数据（i ≤ k）。在 k 步之前，被选中的概率为 1。 当第 k+1 步时，被第 k+1 个数据替换的概率 = 第k+1个元素被选中的概率 * 第i个数 被选中替换的概率，即为则其被保留（取到）的概率为 依次类推，在不被第 k + 1 个元素替换的前提下，不被第k+2 个数据替换的条件概率为则运行到第 n 步时，被保留的概率: ②对于第 j 个数据（j &gt; k）。第 j个数据被选中的概率为 k / j。不被第 j + 1 个元素替换的概率为则运行到第 n步时，被保留的概率 = 被选中的概率 * 不被替换的概率，即条件概率的连乘） 代码实现一些辅助函数 初始化样本数据 抽样过程 封装为类 封装为类之后每次更新值的时候使用update成员函数即可 为支持多种类型，也可以使用泛型类"},{"title":"Kook主题修改指南","date":"2023-02-04T02:17:02.000Z","url":"/2023/02/04/Kook%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97/","tags":[["electron","/tags/electron/"],["kook","/tags/kook/"],["逆向","/tags/%E9%80%86%E5%90%91/"],["js","/tags/js/"],["css","/tags/css/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["逆向","/categories/%E5%AD%A6%E4%B9%A0/%E9%80%86%E5%90%91/"],["electron","/categories/%E5%AD%A6%E4%B9%A0/%E9%80%86%E5%90%91/electron/"],["kook","/categories/%E5%AD%A6%E4%B9%A0/%E9%80%86%E5%90%91/electron/kook/"]],"content":"因为kook是electron编写的 我们可以很方便的去修改界面样式或者加减功能(大部分情况下) KOOK加密了，开摆 定位文件 文件 路径 index.htm C:\\Users\\14368\\AppData\\Local\\KOOK\\app-0.63.0\\resources\\app\\webapp\\build\\index.htm main.js C:\\Users\\14368\\AppData\\Local\\KOOK\\app-0.63.0\\resources\\app\\src\\main.js index.{一串随机值}.js 打开index.htm看 注入样式打开 index.htm 在head添加一行&lt;link href=\"/app/static/css/inject.css\" rel=\"stylesheet\"&gt;这里的inject.css是我们之后要新建的文件,路径为app-0.63.0\\resources\\app\\webapp\\build\\static\\css\\inject.css我修改后的版本如下 这是折叠内容 其中 是我自己用nginx重定向了一个文件如果不需要自定义背景,可以删除这些 添加主题切换功能找到index.{一串随机值}.js用vscode格式化一下,搜索win-logo把onClick:后面的那一串替换为 保存即可 测试重启kook,点击左上角的kook Logo即可更换主题 现有的问题是 kook在一段时间后如果发现你的主题是黑但是实际是白就回给你切换回去,但是自定义主题不受影响 启动时还是默认主题 "},{"date":"2023-02-03T15:10:48.000Z","url":"/2023/02/03/hexo%E5%9B%BE%E5%83%8F%E9%97%AE%E9%A2%98/","categories":[["undefined",""]],"content":"hexo的图像到底是怎么存的,一开独立资源文件夹markdown编辑器就看不了图像"},{"title":"余弦相似度","date":"2023-02-03T14:33:13.000Z","url":"/2023/02/03/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["文本相似度","/tags/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["算法","/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95/"]],"content":"余弦相似性通过测量两个向量的夹角的余弦值来度量它们之间的相似性。0度角的余弦值是1，而其他任何角度的余弦值都不大于1；并且其最小值是-1。从而两个向量之间的角度的余弦值确定两个向量是否大致指向相同的方向。两个向量有相同的指向时，余弦相似度的值为1；两个向量夹角为90°时，余弦相似度的值为0；两个向量指向完全相反的方向时，余弦相似度的值为-1。这结果是与向量的长度无关的，仅仅与向量的指向方向相关。余弦相似度通常用于正空间，因此给出的值为-1到1之间。 注意这上下界对任何维度的向量空间中都适用，而且余弦相似性最常用于高维正空间。例如在信息检索中，每个词项被赋予不同的维度，而一个维度由一个向量表示，其各个维度上的值对应于该词项在文档中出现的频率。余弦相似度因此可以给出两篇文档在其主题方面的相似度。 另外，它通常用于文本挖掘中的文件比较。此外，在数据挖掘领域中，会用到它来度量集群内部的凝聚力。 [1] 定义两个向量间的余弦值可以通过使用欧几里得点积公式求出： 给定两个属性向量，A和B，其余弦相似性θ由点积和向量长度给出，如下所示： 这里的 分别代表向量A和B的各分量。 性质余弦值的范围在[-1,1]之间，值越趋近于1，代表两个向量的方向越接近；越趋近于-1，他们的方向越相反；接近于0，表示两个向量近乎于正交 应用计算文本相似度 应用举例（文本相似度计算）算法 分词 合并 计算特征值 向量化 计算向量夹角余弦值 对于两段文本A和B，对其进行分词，得到两个词列表： 对两个词列表进行合并去重，得到输入样本中的所有词： 计算特征值： 选取词频作为特征值 向量化 计算余弦值 例分词 合并并去重 特征值（词频）计算 向量化 计算余弦 AB的夹角的余弦更趋近于1，所以相似度更高。 "},{"title":"流水线","date":"2023-02-03T14:24:16.000Z","url":"/2023/02/03/%E6%B5%81%E6%B0%B4%E7%BA%BF/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["计算机组成原理","/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"流水线在计算机体系结构中，并行性的最早应用之一是使用流水线将一个复杂的操作分成一系列独立的段，如果不同的段使用不同的资源，且它的前一个操作完成了第一段，立即启动一个操作，这样就能重复执行其他的操作。 流水包括下面的这些级： 取指令（IF） 指令译码（ID） 执行（EX） 存储访间（MEM） 回写（WB） 取指和译码是自明的。为执行的目的，将EX和MEM级组织在一起。 如果指令是一条寄存器到寄存器操作，它能在算术逻辑部件(ALU)中实施，则这一条指令在EX级完成。 如果它是一条存储访问指令，则地址计算在EX级实现，而存储访问实际上是在MEM级发生。 注意，如果需要的存储单元不在高速缓存中，出现不命中，那么这条指令将停顿（stall）直到将需要的块(block)装人高速缓存中。如果指令是分支指令，那么在执行阶段用一个指定寄存器与0比较并在MEM级将PC置成正确的值。WB级用来将数据写回到寄存器中；在分支指令中不使用它。 例子ADD R1, R2, R3 SUB R4, R1, R5 这样的指令序列能没有延地被执行，因为加法指令的结果是直接被送到减法指令的执行级，而不用等待回写到寄存器中。然而，这在 LW R1, 0(R2) ADD R3, R1, R4 序列是不可能的，因为在存储周期结束前，取数指令的结果是不可能得到的。因此，我们看到如下图所描绘的一个周期的停顿。 在上面load和add指令之间插人一条这样的指令，它不使用那个正在取数的寄存器，编译器调度就能消除此问题。 A+B+C 其中浮点加的流水线需要两级。如果按从左到右的顺序对表达式求值，那么第二条加法指令在执行前将不得不等待一个周期，如下图所示。 "},{"title":"搭建博客的过程","date":"2023-01-31T04:42:02.000Z","url":"/2023/01/31/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/","tags":[["web","/tags/web/"],["blog","/tags/blog/"],["github-pages","/tags/github-pages/"],["hexo","/tags/hexo/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"],["hexo","/categories/%E5%AD%A6%E4%B9%A0/hexo/"]],"content":"搭个锤子,先⚪(bushi) github准备工作先创建一个空的仓库,注意格式用户名.github.io hexo安装node使用hexo需要先安装nodejs,选最新版安装就行 安装hexo 新建博客 新建文章 配置主题主题可以在_config.yaml找到找到喜欢的主题之后clone到themes目录下即可然后把_config.yaml中 改为你的主题目录名字 本地预览 生成 上传GitHub安装插件 然后 需要登录的话网页授权一下就行 关于数学公式 网上查了查主要是先替换默认渲染器为kramed(但是我推荐后面装插件的方法) 然后配置主题 我换了之后好像没什么用 然后找到了另一个 这个是可以用的,但是每次要写一大串东西比较麻烦 所以我又安装了 然后在文章开始处配置 "},{"title":"friends","date":"2023-01-31T02:10:34.000Z","url":"/2023/01/31/friends/","categories":[["undefined",""]]},{"title":"Hello World","date":"2023-01-30T17:35:55.366Z","url":"/2023/01/31/hello-world/","tags":[["咕咕咕","/tags/%E5%92%95%E5%92%95%E5%92%95/"]],"categories":[["undefined",""]],"content":"从今天开始，我也是有博客的人啦（雾） 先存一些模板以后用（一个完整的 Front-Matter 区样式 提示信息喵呼呼o(=•ェ•=)m 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠内容 这是打开的可折叠内容 被折叠的内容 1被折叠的内容 2… 这是折叠内容 被折叠的内容 1被折叠的内容 2… 提示内容 面板框的标题 面板里的内容 1面板里的内容 2…TYPE是面板框的类型，可以是： success danger info warning 模糊字符这里有一些被模糊的字符 以上来源于Kratos-Rebirth文档 math c=±a2+b21x2−1c = \\pm\\sqrt{a^2 + b^2}\\frac{1}{x^2-1}c=±a2+b2​x2−11​ 但是上面那2个样式有点问题 "}]